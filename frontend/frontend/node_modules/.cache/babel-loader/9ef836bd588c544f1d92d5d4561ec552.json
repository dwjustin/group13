{"ast":null,"code":"import { __rest } from 'tslib';\nimport { detectAnimationFromOptions } from './utils/detect-animation-from-options.mjs';\nimport sync, { cancelSync } from 'framesync';\nimport { interpolate } from '../utils/interpolate.mjs';\nimport { hasRepeatDelayElapsed, reverseElapsed, loopElapsed } from './utils/elapsed.mjs';\n\nconst framesync = update => {\n  const passTimestamp = _ref => {\n    let {\n      delta\n    } = _ref;\n    return update(delta);\n  };\n\n  return {\n    start: () => sync.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\n\nfunction animate(_a) {\n  var _b, _c;\n\n  var {\n    from,\n    autoplay = true,\n    driver = framesync,\n    elapsed = 0,\n    repeat: repeatMax = 0,\n    repeatType = \"loop\",\n    repeatDelay = 0,\n    onPlay,\n    onStop,\n    onComplete,\n    onRepeat,\n    onUpdate\n  } = _a,\n      options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n\n  let {\n    to\n  } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n\n  const animation = animator(Object.assign(Object.assign({}, options), {\n    from,\n    to\n  }));\n\n  function repeat() {\n    repeatCount++;\n\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n\n    if (isComplete) {\n      if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\nexport { animate };","map":{"version":3,"sources":["/Users/aditummala/Desktop/group13-1/frontend/frontend/node_modules/popmotion/dist/es/animations/index.mjs"],"names":["__rest","detectAnimationFromOptions","sync","cancelSync","interpolate","hasRepeatDelayElapsed","reverseElapsed","loopElapsed","framesync","update","passTimestamp","delta","start","stop","animate","_a","_b","_c","from","autoplay","driver","elapsed","repeat","repeatMax","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate","options","to","driverControls","repeatCount","computedDuration","duration","latest","isComplete","isForwardPlayback","interpolateFromNumber","animator","needsInterpolation","call","clamp","animation","Object","assign","flipTarget","complete","state","next","Math","max","value","done","play"],"mappings":"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","sourcesContent":["import { __rest } from 'tslib';\nimport { detectAnimationFromOptions } from './utils/detect-animation-from-options.mjs';\nimport sync, { cancelSync } from 'framesync';\nimport { interpolate } from '../utils/interpolate.mjs';\nimport { hasRepeatDelayElapsed, reverseElapsed, loopElapsed } from './utils/elapsed.mjs';\n\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\nexport { animate };\n"]},"metadata":{},"sourceType":"module"}